const config = require('../config')
const { cmd, commands } = require('../command')
const prefix = config.PREFIX;
const fs = require('fs');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, sleep, fetchJson } = require('../lib/functions2');
const { writeFileSync } = require('fs');
const path = require('path');



cmd({
    pattern: "updategdesc",
    alias: ["upgdesc", "gdesc"],
    react: "üìú",
    desc: "Change the group description.",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, args, q, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to update the group description.");
        if (!q) return reply("‚ùå Please provide a new group description.");

        await conn.groupUpdateDescription(from, q);
        reply("‚úÖ Group description has been updated.");
    } catch (e) {
        console.error("Error updating group description:", e);
        reply("‚ùå Failed to update the group description. Please try again.");
    }
});

cmd({
    pattern: "updategname",
    alias: ["upgname", "gname"],
    react: "üìù",
    desc: "Change the group name.",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, args, q, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to update the group name.");
        if (!q) return reply("‚ùå Please provide a new group name.");

        await conn.groupUpdateSubject(from, q);
        reply(`‚úÖ Group name has been updated to: *${q}*`);
    } catch (e) {
        console.error("Error updating group name:", e);
        reply("‚ùå Failed to update the group name. Please try again.");
    }
});


cmd({
    pattern: "ginfo",
    react: "ü•è",
    alias: ["groupinfo"],
    desc: "Get group informations.",
    category: "group",
    use: '.ginfo',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator ,isDev, isAdmins, reply}) => {
try{
const msr = (await fetchJson('https://raw.githubusercontent.com/JawadTech3/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg

if (!isGroup) return reply(msr.only_gp)
if (!isAdmins) { if (!isDev) return reply(msr.you_adm),{quoted:mek }} 
if (!isBotAdmins) return reply(msr.give_adm)
const ppUrls = [
        'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png',
        'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png',
        'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png',
      ];
let ppUrl = await conn.profilePictureUrl( from , 'image')
if (!ppUrl) { ppUrl = ppUrls[Math.floor(Math.random() * ppUrls.length)];}
const metadata = await conn.groupMetadata(from)
const groupAdmins = participants.filter(p => p.admin);
const listAdmin = groupAdmins.map((v, i) => `${i + 1}. @${v.id.split('@')[0]}`).join('\n');
const owner = metadata.owner

const gdata = `*„Äå Group Information „Äç*\n
\t*${metadata.subject}*

*Group Jid* - ${metadata.id}
*Participant Count* - ${metadata.size}
*Group Creator* - ${owner.split('@')[0]}
*Group Description* - ${metadata.desc?.toString() || 'undefined'}\n
*Group Admins* - \n${listAdmin}\n`

await conn.sendMessage(from,{image:{url: ppUrl },caption: gdata },{quoted:mek })
} catch (e) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } })
console.log(e)
reply(`‚ùå *Error Accurated !!*\n\n${e}`)
}
} )


cmd({
    pattern: "join",
    react: "üì¨",
    alias: ["joinme","f_join"],
    desc: "To Join a Group from Invite link",
    category: "group",
    use: '.join < Group Link >',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator ,isDev, isAdmins, reply}) => {
try{
const msr = (await fetchJson('https://raw.githubusercontent.com/XdTechPro/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg

if (!isCreator && !isDev && !isOwner && !isMe) return reply(msr.own_cmd)
if (!q) return reply("*Please write the Group Link*Ô∏è üñáÔ∏è")
 let result = args[0].split('https://chat.whatsapp.com/')[1]
 await conn.groupAcceptInvite(result)
     await conn.sendMessage(from , { text: `‚úîÔ∏è *Successfully Joined*`}, { quoted: mek } )
} catch (e) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } })
console.log(e)
reply(`‚ùå *Error Accurated !!*\n\n${e}`)
}
} )


cmd({
    pattern: "join",
    react: "üì¨",
    alias: ["joinme","f_join"],
    desc: "To Join a Group from Invite link",
    category: "group",
    use: '.join < Group Link >',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator ,isDev, isAdmins, reply}) => {
try{
const msr = (await fetchJson('https://raw.githubusercontent.com/XdTechPro/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg

if (!isCreator && !isDev && !isOwner && !isMe) return reply(msr.own_cmd)
if (!q) return reply("*Please write the Group Link*Ô∏è üñáÔ∏è")
 let result = args[0].split('https://chat.whatsapp.com/')[1]
 await conn.groupAcceptInvite(result)
     await conn.sendMessage(from , { text: `‚úîÔ∏è *Successfully Joined*`}, { quoted: mek } )
} catch (e) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } })
console.log(e)
reply(`‚ùå *Error Accurated !!*\n\n${e}`)
}
} )


cmd({
    pattern: "lockgc",
    alias: ["lock"],
    react: "üîí",
    desc: "Lock the group (Prevents new members from joining).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to lock the group.");

        await conn.groupSettingUpdate(from, "locked");
        reply("‚úÖ Group has been locked. New members cannot join.");
    } catch (e) {
        console.error("Error locking group:", e);
        reply("‚ùå Failed to lock the group. Please try again.");
    }
});
    

cmd({
  pattern: "newgc",
  category: "group",
  desc: "Create a new group and add participants.",
  filename: __filename,
}, async (conn, mek, m, { from, isGroup, body, sender, groupMetadata, participants, reply }) => {
  try {
    if (!body) {
      return reply(`Usage: !newgc group_name;number1,number2,...`);
    }

    const [groupName, numbersString] = body.split(";");
    
    if (!groupName || !numbersString) {
      return reply(`Usage: !newgc group_name;number1,number2,...`);
    }

    const participantNumbers = numbersString.split(",").map(number => `${number.trim()}@s.whatsapp.net`);

    const group = await conn.groupCreate(groupName, participantNumbers);
    console.log('created group with id: ' + group.id); // Use group.id here

    const inviteLink = await conn.groupInviteCode(group.id); // Use group.id to get the invite link

    await conn.sendMessage(group.id, { text: 'hello there' });

    reply(`Group created successfully with invite link: https://chat.whatsapp.com/${inviteLink}\nWelcome message sent.`);
  } catch (e) {
    return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
  }
});




cmd({
    pattern: "out",
    alias: ["ck", "ü¶∂", "kickcc", "removecode", "ccout"],
    desc: "Removes all members with specific country code from the group",
    category: "admin",
    react: "‚ùå",
    filename: __filename
},
async (conn, mek, m, {
    from, q, isGroup, isBotAdmins, reply, groupMetadata, senderNumber
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("‚ùå This command can only be used in groups.");

    // Get the bot owner's number dynamically from conn.user.id
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return reply("‚ùå Only the bot owner can use this command.");
    }

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("‚ùå I need to be an admin to use this command.");

    if (!q) return reply("‚ùå Please provide a country code. Example: .out 92");

    const countryCode = q.trim();
    if (!/^\d+$/.test(countryCode)) {
        return reply("‚ùå Invalid country code. Please provide only numbers (e.g., 92 for +92 numbers)");
    }

    try {
        const participants = await groupMetadata.participants;
        const targets = participants.filter(
            participant => participant.id.startsWith(countryCode) && 
                         !participant.admin // Don't remove admins
        );

        if (targets.length === 0) {
            return reply(`‚ùå No members found with country code +${countryCode}`);
        }

        const jids = targets.map(p => p.id);
        await conn.groupParticipantsUpdate(from, jids, "remove");
        
        reply(`‚úÖ Successfully removed ${targets.length} members with country code +${countryCode}`);
    } catch (error) {
        console.error("Out command error:", error);
        reply("‚ùå Failed to remove members. Error: " + error.message);
    }
});

cmd({
    pattern: "poll",
    category: "group",
    desc: "Create a poll with a question and options in the group.",
    filename: __filename,
  }, async (conn, mek, m, { from, isGroup, body, sender, groupMetadata, participants, prefix, pushname, reply }) => {
    try {
      let [question, optionsString] = body.split(";");
      
      if (!question || !optionsString) {
        return reply(`Usage: ${prefix}poll question;option1,option2,option3...`);
      }
  
      let options = [];
      for (let option of optionsString.split(",")) {
        if (option && option.trim() !== "") {
          options.push(option.trim());
        }
      }
  
      if (options.length < 2) {
        return reply("*Please provide at least two options for the poll.*");
      }
  
      await conn.sendMessage(from, {
        poll: {
          name: question,
          values: options,
          selectableCount: 1,
          toAnnouncementGroup: true,
        }
      }, { quoted: mek });
    } catch (e) {
      return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
  });

  cmd({
    pattern: "revoke",
    react: "üñáÔ∏è",
    alias: ["revokegrouplink","resetglink","revokelink","f_revoke", "resetgclink"],
    desc: "To Reset the group link",
    category: "group",
    use: '.revoke',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator ,isDev, isAdmins, reply}) => {
try{
const msr = (await fetchJson('https://raw.githubusercontent.com/XdTechPro/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg

if (!isGroup) return reply(msr.only_gp)
if (!isAdmins) { if (!isDev) return reply(msr.you_adm),{quoted:mek }} 
if (!isBotAdmins) return reply(msr.give_adm)
await conn.groupRevokeInvite(from)
 await conn.sendMessage(from , { text: `*Group link Reseted* ‚õî`}, { quoted: mek } )
} catch (e) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } })
console.log(e)
reply(`‚ùå *Error Accurated !!*\n\n${e}`)
}
} )

cmd({
    pattern: "hidetag",
    react: "üîä",
    desc: "To Tag all Members for Message",
    category: "group",
    use: '.tag Hi',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, mentionByTag , args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator ,isDev, isAdmins, reply}) => {
try{
const msr = (await fetchJson('https://raw.githubusercontent.com/XdTechPro/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg

if (!isGroup) return reply(msr.only_gp)
if (!isAdmins) { if (!isDev) return reply(msr.you_adm),{quoted:mek }} 
if (!isBotAdmins) return reply(msr.give_adm)
	
		if(!q) return reply('*Please add a Message* ‚ÑπÔ∏è')
		let teks = `${q}`
                conn.sendMessage(from, { text: teks, mentions: participants.map(a => a.id) }, { quoted: mek })
                
} catch (e) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } })
console.log(e)
reply(`‚ùå *Error Accurated !!*\n\n${e}`)
}
} )

cmd({
    pattern: "unlockgc",
    alias: ["unlock"],
    react: "üîì",
    desc: "Unlock the group (Allows new members to join).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to unlock the group.");

        await conn.groupSettingUpdate(from, "unlocked");
        reply("‚úÖ Group has been unlocked. New members can now join.");
    } catch (e) {
        console.error("Error unlocking group:", e);
        reply("‚ùå Failed to unlock the group. Please try again.");
    }
});

cmd({
    pattern: "unmute",
    alias: ["groupunmute"],
    react: "üîä",
    desc: "Unmute the group (Everyone can send messages).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, senderNumber, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to unmute the group.");

        await conn.groupSettingUpdate(from, "not_announcement");
        reply("‚úÖ Group has been unmuted. Everyone can send messages.");
    } catch (e) {
        console.error("Error unmuting group:", e);
        reply("‚ùå Failed to unmute the group. Please try again.");
    }
});